# 테스트 코드

인터페이스를 기준으로 테스트를 작성할 것.

- 서로 다른 클래스 또는 모듈이 상호작용하는 시스템

```jsx
// 잘못된 테스트 코드
it(’isShowModal 상태를 true로 변경했을 때 modalComponent의 display 스타일이 block 이며, “안녕하세요!” 테스트가 노출된다.’, () ⇒ {
	speciticComponent.setState({ isShowModal: true })
}
```

1. 변경되는 상태가 많은 경우 테스트 코드 상에서 일일이 직접 변경해야 하며 어떤 상황에서 변경 되는 것인지 드러나지 않음.
2. 내부 상태나 변수값을 기준으로 검증하다 보니 어떤 것을 검증하는지 테스트 코드만 보고 한 눈에 파악하기 어려움.
3. 내부 구현을 검증하려다 보니 구현에 종속적인 테스트 코드가 양산됨으로 상태나 변수명이 하나라도 바뀌면 테스트 코드 모두 바꿔야 함. (즉, 캡슐화를 위반하는 코드가 된다.)

```jsx
// 올바른 테스트 코드
it("버튼을 누르면 모달을 띄운다.", () => {
	user.click(screen.getByRole('button'));
})
```

Dom event handler

1. 내부 구현과 종속성이 없으며 캡슐화에 위반되지 않음.
2. 어떤 행위를 하는지 명확해짐
3. 테스트를 설명하기 위한 불필요한 주석이나 설명 없음.

<aside>
💡 커버리지 보다는 의미있는 테스트인지 고민하자.
커버리지: 테스트 코드가 프로덕션 코드의 몇 퍼센트를 검증하고 있는지 나타낸 지표(구문, 분기, 함수, 줄 등을 기준으로 함)

</aside>

테스트 코드도 유지보수의 대상이자 가독성도 높이자.

1. 테스트 하고자 하는 내용을 명확하게 적자.

```jsx
// 검증기능: 리스트에서 체크된 항목들을 삭제
🙅🏻‍♀️
****it('리스트에서 항목이 제대로 삭제된다.', () => {
	// ...
})

🙆🏻‍♀️
****it('항목들을 체크한 후 삭제 버튼을 누르면 리스트에서 체크된 항목들이 삭제된다.', () => {
	// ...
})
```

1. 하나의 테스트에서 가급적 하나의 동작만 검증하자.
   단일 책임원칙(SRP, Single Responsibiliry Principle)
   모든 클래스는 하나의 책임을 갖고 그와 관련된 책임을 캡슐화하여 변경에 견고한 코드를 만들어야 한다.

    ```jsx
    // 검증기능: 장바구니 테스트
    🙅🏻‍♀️
    ****it('장바구니에 담긴 상품들이 정상적으로 노출되고, 수량 변경하여 가격이 재계산된다. 그리고 삭제 버튼을 누르면 상품이 삭제된다.', () => {
    	// ...
    })
    
    🙆🏻‍♀️
    ****it('장바구니에 담긴 상품들을 정상적으로 렌더링 한다.', () => {
    	// ...
    })
    it('장바구니에 담긴 상품의 수량을 수정하면 가격이 재계산된다.', () => {
    	// ...
    })
    it('장바구니에 담긴 항목의 삭제 버튼을 누르면 리스트에서 삭제된다.', () => {
    	// ...
    })
    ```


### 단위 테스트

앱에서 테스트 가능한 가장 작은 소프트웨어를 실행해 예상대로 동작하는지 확인하는 테스트

- 단일 함수 또는 단일 컴포넌트(클래스)
- 공통 컴포넌트 (버튼, 텍스트 인풋, 캐러샐, 아코디언 등)

Arrange-Act-Assert 테스트 작성 패턴

1. Arrange: 테스트를 위한 환경 만들기
2. Act: 테스트할 동작 발생
3. Assert: 올바른 동작이 실행 되었는지 또는 변경사항 검증하기